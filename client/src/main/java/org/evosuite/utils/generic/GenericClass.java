package org.evosuite.utils.generic;

import com.googlecode.gentyref.GenericTypeReflector;
import org.evosuite.Properties;
import org.evosuite.ga.ConstructionFailedException;

import java.io.Serializable;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * Interface for a generic class representation.
 *
 * All instantiate of this interface should be generated by {@code GenericClassFactory}
 * in order to ensure only one implementation is used at runtime.
 */
public interface GenericClass<T extends GenericClass<T>> extends Serializable {

    T self();

    /**
     * Determine if there exists an instantiation of the type variables such that the class matches
     * otherType
     *
     * @param otherType is the class we want to generate
     * @return whether this generic class can be instantiated to the given type.
     */
    boolean canBeInstantiatedTo(GenericClass<?> otherType);

    /**
     * change the class loader of this generic class.
     *
     * @param loader the class loader to be used.
     * @return whether changing the class loader was successful,.
     */
    boolean changeClassLoader(ClassLoader loader);

    // TODO: Why is this unused? Maybe we can remove this functionality / move it to a Utility function...
    /**
     * Get the boxed type of the represented generic class, if it is a primitive type.
     * If not, the rawClass is returned.
     *
     * @return Boxed type for primitive types, otherwise the raw class.
     */
    Class<?> getBoxedType();

    /**
     * The name of the represented generic class.
     * See {@link Class#getName()} for the exact format of the name.
     *
     * @return the name of the raw class.
     */
    String getClassName();

    /**
     * If the represented generic class represents an array, return the component class of the array.
     *
     * E.g:
     *      GenericClass(int[].class) has the component type int
     *      GenericClass(A<B>[].class) has the component type A<B>
     *
     * If the generic class is not an array, its behaviour is undefined.
     *
     * @return the component type of the array
     */
    GenericClass<?> getComponentClass();

    /**
     * If the represented generic class represents an aray, return the name of its component class.
     *
     * If the generic class is not an array, its behaviour is undefined.
     *
     * @return the name of the component type.
     */
    String getComponentName();

    /**
     * Alias for {@code TypeUtils#getArrayComponentType} with getType() as argument.
     *
     * @return the component type of the array as provided from TypeUtils.
     */
    Type getComponentType();

    // TODO: write proper documentation.
    /**
     * Compute the generic boundaries of this generic class.
     *
     * @return the generic boundaries.
     */
    Collection<GenericClass<?>> getGenericBounds();

    /**
     * Generate a possible instantiation of this generic class randomly.
     * All type variables are instantiated randomly.
     *
     * The generic depth is assumed to be 0, e.g. this generic class is not used as parameter of another generic class.
     *
     * If this generic class has no wildcards or type variables, a copy of this generic class is returned.
     *
     * @return an instantiation of this generic class.
     * @throws ConstructionFailedException if no instantiation could be constructed.
     */
    GenericClass<?> getGenericInstantiation() throws ConstructionFailedException;

    /**
     * Generate a possible instantiation of this generic class randomly.
     *
     * The generic depth is assumed to be 0, e.g. this generic class is not used as parameter of another generic class.
     *
     * If this generic class has no wildcards or type variables, a copy of this generic class is returned.
     *
     * @param typeMap Constraints to the type variables of this generic class.
     * @return an instantiation of this generic class.
     * @throws ConstructionFailedException if no instantiation could be constructed.
     */
    GenericClass<?> getGenericInstantiation(Map<TypeVariable<?>, Type> typeMap) throws ConstructionFailedException;

    /**
     * Generate a possible instantiation of this generic class randomly.
     *
     * The current generic depth of the instantiation can be set with {@param recursionLevel} to ensure the
     * maximal generic depth {@link Properties#MAX_GENERIC_DEPTH} is respected.
     * This should only be relevant for instantiating the parameter of another generic class.
     *
     * If this generic class has no wildcards or type variables, a copy of this generic class is returned.
     *
     * @param typeMap Constraints to the type variables of this generic class.
     * @param recursionLevel the maximal generic depth of the instantiation.
     * @return an instantiation of this generic class.
     * @throws ConstructionFailedException if no instantiation could be constructed.
     */
    GenericClass<?> getGenericInstantiation(Map<TypeVariable<?>, Type> typeMap, int recursionLevel) throws ConstructionFailedException;

    /**
     * Get the interfaces, that this class implements.
     *
     * @return a List of {@link GenericClass}, each element represents one interface.
     */
    List<GenericClass<?>> getInterfaces();

    /**
     * Get the number of type parameters of this type.
     * This does not include type parameters of super classes that are fixed by this class.
     *
     * @return the number of type parameters of this class.
     */
    int getNumParameters();

    /**
     * If this is a parameterized type, its owner type is returned as a GenericClass.
     *
     * IF this is not a parameterized type, its behaviour is undefined.
     *
     * @return the owner type as {@link GenericClass}.
     */
    GenericClass<?> getOwnerType();

    /**
     * A list containing the generic type parameters (as {@link Type} objects) of the represented generic class.
     *
     * The order of the list is equal to the order of the generic parameters (from left to right).
     *
     * @return a view of the described list.
     */
    List<Type> getParameterTypes();

    /**
     * A list containing the generic type parameters (as {@link GenericClass} objects) of the represented generic class.
     *
     * The order of the list is equal to the order of the generic parameters (from left to right).
     *
     * @return a view of the described list.
     */
    List<GenericClass<?>> getParameterClasses();

    /**
     * Get the raw class (without generic information) of this class.
     *
     * @return the raw class.
     */
    Class<?> getRawClass();

    // TODO: Why is this unused? Maybe we can remove this functionality / move it to a Utility function...
    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    Type getRawComponentClass();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    String getSimpleName();

    // TODO: write proper documentation.
    /**
     * Get the generic super class of this generic class.
     *
     * The generic information of the super class is inferred from this generic class.
     *
     * See {@link GenericTypeReflector#getExactSuperType} for additional information.
     *
     * @return the generic super class.
     */
    GenericClass<?> getSuperClass();

    /**
     * Get the represented {@link java.lang.reflect.Type} object.
     */
    Type getType();

    /**
     * Alias for {@link GenericTypeReflector#getTypeName} of the represented class.
     */
    String getTypeName();

    /**
     * The type variable map is a mapping from a {@link TypeVariable} to a {@link Type} object:
     *
     * The key set of the mapping is the set of type variables of this generic class.
     * THe value of every set is the constraint, of this type variable for this generic class.
     *
     * @return a view on the type variable map
     */
    Map<TypeVariable<?>, Type> getTypeVariableMap();

    /**
     * Return a list of type variables of this type, or an empty list if this is not a parameterized
     * type
     *
     * @return a view of the list.
     */
    List<TypeVariable<?>> getTypeVariables();

    /**
     * Return the unboxed type of this generic class if this is a wrapper type (e.g. {@link Integer})
     *
     * @return the raw class of the unboxed type.
     */
    Class<?> getUnboxedType();

    // TODO: write proper documentation.
    /**
     *
     * @param componentClass
     * @return
     */
    GenericClass<?> getWithComponentClass(GenericClass<?> componentClass);

    // TODO: Why is this unused? Maybe we can remove this functionality / move it to a Utility function...
    // TODO: write proper documentation.
    /**
     *
     * @param parameters
     * @return
     */
    GenericClass<?> getWithGenericParameterTypes(List<T> parameters);

    // TODO: write proper documentation.
    /**
     *
     * @param superClass
     * @return
     * @throws ConstructionFailedException
     */
    GenericClass<?> getWithParametersFromSuperclass(GenericClass<?> superClass) throws ConstructionFailedException;

    // TODO: write proper documentation.
    /**
     *
     * @param parameters
     * @return
     */
    GenericClass<?> getWithParameterTypes(List<Type> parameters);

    // TODO: write proper documentation.
    /**
     *
     * @param parameters
     * @return
     */
    GenericClass<?> getWithParameterTypes(Type[] parameters);

    /**
     * Replaces all type parameters with unbound wildcards ("?").
     *
     * An example implementation on type level is: {@link GenericTypeReflector#addWildcardParameters(Class)}
     * An implementation of this function may only be a wrapper of this function.
     *
     * @return This generic class with replaced parameters.
     */
    GenericClass<?> getWithWildcardTypes();

    // TODO: write proper documentation.
    /**
     *
     * @param superType
     * @return
     */
    boolean hasGenericSuperType(GenericClass<?> superType);

    // TODO: Why is this unused? Maybe we can remove this functionality / move it to a Utility function...
    // TODO: write proper documentation.
    /**
     *
     * @param superType
     * @return
     */
    boolean hasGenericSuperType(Type superType);

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean hasOwnerType();

    /**
     * Check if the represented generic class contains any type parameters
     * or wildcards.
     *
     * For inner classes, the type parameters and wildcards of the owner type
     * are also considered.
     *
     * If the represented generic class is a array type,
     * the method call is delegated to the component class of the array.
     *
     * @return Whether the generic class has any type parameter or wildcard
     */
    boolean hasWildcardOrTypeVariables();

    /**
     * Checks if this generic class contains or is a type variables.
     *
     * If this generic class is a parameterized type,
     * all parameter types are checked recursively for type variables.
     *
     * E.g. A<B<T>> returns true, if T is a type variable
     *
     * @return Whether type has a type variable.
     */
    boolean hasTypeVariables();


    /**
     * Checks if this generic class contains or is a wildcard types.
     *
     * If this generic class is a parameterized type,
     * all parameter types are checked recursively for wildcards.
     *
     * E.g. A<B<?>> returns true.
     *
     * @return Whether this generic class contains or is a wildcard type.
     */
    boolean hasWildcardTypes();

    /**
     * @return Whether this generic class is abstract.
     */
    boolean isAbstract();

    /**
     * @return Whether this generic class is anonymous.
     */
    boolean isAnonymous();

    /**
     * @return whether this generic class is an array.
     */
    boolean isArray();

    // TODO: write proper documentation.
    /**
     *
     * @param rhsType
     * @return
     */
    boolean isAssignableFrom(GenericClass<?> rhsType);

    // TODO: write proper documentation.
    /**
     *
     * @param rhsType
     * @return
     */
    boolean isAssignableFrom(Type rhsType);

    // TODO: write proper documentation.
    /**
     *
     * @param lhsType
     * @return
     */
    boolean isAssignableTo(GenericClass<?> lhsType);

    // TODO: write proper documentation.
    /**
     *
     * @param lhsType
     * @return
     */
    boolean isAssignableTo(Type lhsType);

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isClass();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isEnum();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isGenericArray();

    // TODO: write proper documentation.
    /**
     *
     * @param subType
     * @return
     */
    boolean isGenericSuperTypeOf(GenericClass<?> subType);

    // TODO: Why is this unused? Maybe we can remove this functionality / move it to a Utility function...
    // TODO: write proper documentation.
    /**
     *
     * @param subType
     * @return
     */
    boolean isGenericSuperTypeOf(Type subType);

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isObject();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isParameterizedType();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isPrimitive();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isRawClass();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isTypeVariable();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isWildcardType();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isString();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isVoid();

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    boolean isWrapperType();

    /**
     * Determine whether the boundaries of the type variable are satisfied
     * without any additional constraints regarding the type variables.
     *
     * @param typeVariable the type variable to be checked
     * @return whether this class satisfies the boundaries of the type variable.
     */
    boolean satisfiesBoundaries(TypeVariable<?> typeVariable);

    /**
     * Determine whether the boundaries of the type variable are satisfied by this class
     * with additional constraints regarding the type variables.
     *
     * Every entry of {@param typeNap} is an constraint that enforces the key/type variable
     * to be an instance of the value/type.
     *
     * @param typeVariable The type variable, that should be checked.
     * @param typeMap The map of constraints.
     * @return Wether the boundaries of the type variable are satisfied by this class for the given set of constraints.
     */
    boolean satisfiesBoundaries(TypeVariable<?> typeVariable, Map<TypeVariable<?>, Type> typeMap);

    // TODO: write proper documentation.
    /**
     *
     * @param wildcardType
     * @return
     */
    boolean satisfiesBoundaries(WildcardType wildcardType);

    // TODO: write proper documentation.
    /**
     *
     * @param wildcardType
     * @param typeMap
     * @return
     */
    boolean satisfiesBoundaries(WildcardType wildcardType, Map<TypeVariable<?>, Type> typeMap);

    // TODO: write proper documentation.
    /**
     *
     * @return
     */
    GenericClass<?> getRawGenericClass();

    // TODO: write proper documentation.
    /**
     *
     * @param typeMap
     * @param recursionLevel
     * @return
     * @throws ConstructionFailedException
     */
    GenericClass<?> getGenericWildcardInstantiation(Map<TypeVariable<?>, Type> typeMap, int recursionLevel) throws ConstructionFailedException;

    /**
     * Sets the represented type of a copy of this generic class
     *
     * @param type the type to be set.
     * @return the copy.
     */
    GenericClass<?> setType(Type type);
}
